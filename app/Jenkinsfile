pipeline {
    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['staging', 'production'], description: 'Choose environment to deploy')
    }


    environment {
        KOSLI_ORG = 'kosli-public'
        KOSLI_API_TOKEN = credentials('kosli-api-key')
        SNYK_TOKEN = credentials('snyk-api-token')
        DOCKER_PASSWORD = credentials('docker-hub-pat')
        SHORT_SHA = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        DOCKER_API_VERSION = '1.44'
        CX_COMPLIANCE = 'compliant'  // 'compliant' or 'non_compliant'
        CX_REFRESH_TOKEN = credentials('checkmarx-refresh-token')
        CX_PROJECT_ID = '0af76263-3d75-482c-ae9e-171b7d046e7c'
        CX_REPO_URL = 'https://github.com/kosli-dev/jenkins-java-example'
    }
    agent any

    stages {
        stage('Checkout') {
            steps {
                // Checkout the code from the repository
                checkout scm
                sh 'pwd'
                sh 'ls -al'
            }
        }
        stage('Build') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                dir('app') {
                    // Run the Gradle build
                    sh './gradlew build'
                    sh 'ls -al app/build/libs'
                }
                sh '''
                        kosli attest artifact app/app/build/libs/app.jar \
	                        --artifact-type file \
	                        --flow jenkins-java-example \
	                        --trail $GIT_COMMIT \
	                        --name jarfile
                    '''
            }
        }

        stage('Test') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                dir('app') {
                    // Run the Gradle tests
                    sh './gradlew test'
                }
            }
        }

       stage('Checkmarx Scan') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                // - authenticate with checkmarx
                // - trigger async scan
                // - get results from scan via its ID
                // - attest scan result
                // - assert scan result
                dir('app') {
                    script {
                        @NonCPS
                        def sleepTen() {
                            echo "Sleeping for 10 seconds..."
                            sleep 10
                        }

                        def response = sh(script: """
                            curl -X POST \
                            https://deu.iam.checkmarx.net/auth/realms/kosli-nfr/protocol/openid-connect/token \
                            --data "grant_type=refresh_token" \
                            --data "client_id=ast-app" \
                            --data "refresh_token=${CX_REFRESH_TOKEN}"
                        """, returnStdout: true).trim()
                        
                        def accessToken = new groovy.json.JsonSlurper().parseText(response).access_token

                        def scanCreationResponse = sh(script: """
                            curl --request POST \
                            https://deu.ast.checkmarx.net/api/scans/ \
                            --header 'Accept: application/json' \
                            --header "Authorization: Bearer ${accessToken}" \
                            --header 'Content-Type: application/json; version=1.0' \
                            --data '{
                                "project": { 
                                    "id": "${CX_PROJECT_ID}" 
                                },
                                "type": "git",
                                "handler": {
                                    "repoUrl": "${CX_REPO_URL}",
                                    "branch": "develop"
                                },
                                "config": [
                                    {
                                        "type": "sca",
                                        "value": {
                                            "incremental": "true",
                                            "presetName": "Default"
                                        }
                                    }
                                ]
                            }'
                        """, returnStdout: true).trim()
                        def scanId = new groovy.json.JsonSlurper().parseText(scanCreationResponse).id
                        echo "Scan ID: ${scanId}"

                        // Poll for scan completion
                        def scanStatus = "Running"
                        def scanDetails = ""
                        while (scanStatus == "Running") {
                            scanDetails = sh(script: """
                                curl --request GET \
                                --url https://deu.ast.checkmarx.net/api/scans/${scanId} \
                                --header 'Accept: application/json; version=1.0' \
                                --header "Authorization: Bearer ${accessToken}"
                            """, returnStdout: true).trim()
                            def scanJson = new groovy.json.JsonSlurper().parseText(scanDetails)
                            scanStatus = scanJson.status
                            // echo "Current scan status: ${scanStatus}"
                            if (scanStatus == "Running") {
                                echo "Going to wait for 10 seconds before checking again..."
                                sleepTen()
                                echo "Waiting for scan to complete..."
                            }
                        }
                        echo "done."
                    }
                }
                // Attest the Checkmarx scan result
                sh '''
                    kosli attest custom \
                        --type checkmarx-scan \
                        --flow jenkins-java-example \
                        --trail $GIT_COMMIT \
                        --name checkmarx-scan \
                        --attestation-data .checkmarx/cx_scan_result_${CX_COMPLIANCE}.json
                ''' 
            }
        }

        stage('Snyk Scan') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                dir('app') {
                    // Run the Snyk scan
                    sh 'snyk auth $SNYK_TOKEN'
                    sh 'snyk code test --all-projects --org=b6132233-66fe-49e8-a9ba-9d42cea007f1 --sarif-file-output=snyk-code-test.json'
                    sh 'snyk test --all-projects --org=b6132233-66fe-49e8-a9ba-9d42cea007f1'
                    
                }
                sh '''
                    kosli attest custom \
                        --type custom-snyk-scan \
                        --flow jenkins-java-example \
                        --trail $GIT_COMMIT \
                        --name snyk-scan \
                        --attestation-data app/snyk-code-test.json
                ''' 
            }
        }

        stage('SonarCloud analysis') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                dir('app') {
                    withSonarQubeEnv('SonarQube Cloud') { // Will pick the global server connection you have configured
                        sh './gradlew sonar'
                    }
                }
            }
        }

        stage('Archive') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {

                // Archive the build artifacts
                archiveArtifacts artifacts: 'app/app/build/libs/*.jar', allowEmptyArchive: false
            }
        }

        // Build and push Docker image
        stage('Docker Build and Push') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                dir('app') {
                    // Build and push the Docker image for linux/amd64 architecture
                    sh "docker login -u meekrosoft -p $DOCKER_PASSWORD"
                    sh "docker buildx create --use || true"
                    sh "docker buildx build --platform linux/amd64 -t meekrosoft/jenkins-java-example:${SHORT_SHA} --load ."
                    sh "docker push meekrosoft/jenkins-java-example:${SHORT_SHA}"
                    sh "docker image inspect meekrosoft/jenkins-java-example:${SHORT_SHA}"
                }
                sh '''
                    kosli attest artifact meekrosoft/jenkins-java-example:${SHORT_SHA} \
                        --artifact-type oci \
                        --flow jenkins-java-example \
                        --trail $GIT_COMMIT \
                        --name docker-image \
                        --registry-username meekrosoft \
                        --registry-password $DOCKER_PASSWORD
                '''
            }
        }

        stage('Assert Artifact') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                script {
                    def imageDigest = sh(script: "docker image inspect meekrosoft/jenkins-java-example:${SHORT_SHA} --format '{{.RepoDigests}}' | grep -o 'sha256:[a-f0-9]*' | cut -d':' -f2", returnStdout: true).trim()
                    
                    def response = sh(script: """
                        curl -X 'GET' \\
                          'https://app.kosli.com/api/v2/asserts/kosli-public/fingerprint/${imageDigest}?flow_name=jenkins-java-example' \\
                          -H 'accept: application/json' \\
                          -H 'Authorization: Bearer ${KOSLI_API_TOKEN}'
                    """, returnStdout: true).trim()
                    
                    def jsonResponse = new groovy.json.JsonSlurper().parseText(response)
                    echo "Parsed response - compliant: ${jsonResponse.compliant}, html_url: ${jsonResponse.html_url}"
                    
                    if (!jsonResponse.compliant) {
                        error "Kosli artifact assertion failed: artifact is not compliant"
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                expression { params.DEPLOY_ENV == null || params.DEPLOY_ENV == 'staging' }
            }
            steps {
                // Apply the Kubernetes manifests
                sh '''
                    kosli snapshot k8s jenkins-java-example-staging -n staging

                    aws eks update-kubeconfig --name kosli-demo
                    export KUBECONFIG=/root/.kube/config

                    export IMAGE_TAG=${SHORT_SHA}
                    export IMAGE_NAME=jenkins-java-example
                    envsubst < app/k8s/deployment.yaml | kubectl apply -n staging -f -

                    # Wait for deployment to be ready
                    kubectl rollout status deployment/jenkins-java-example -n staging

                    echo "Waiting for 30 seconds before taking snapshot"
                    sleep 30
                    kosli snapshot k8s jenkins-java-example-staging -n staging
                '''
            }
        }
        stage('Deploy to Production') {
            when {
                expression { params.DEPLOY_ENV == 'production' }
            }
            steps {
                // Apply the Kubernetes manifests to production
                sh '''
                    kosli snapshot k8s jenkins-java-example-prod -n production

                    aws eks update-kubeconfig --name kosli-demo
                    export KUBECONFIG=/root/.kube/config
                    
                    export IMAGE_TAG=${SHORT_SHA}
                    export IMAGE_NAME=jenkins-java-example
                    envsubst < app/k8s/deployment.yaml | kubectl apply -n production -f -
                    
                    # Wait for deployment to be ready
                    kubectl rollout status deployment/jenkins-java-example -n production

                    echo "Waiting for 30 seconds before taking snapshot"
                    sleep 30
                    kosli snapshot k8s jenkins-java-example-prod -n production
                '''
            }
        }
    }

    post {
        always {
            // Clean up the workspace after the build
            cleanWs()
        }
    }
}
